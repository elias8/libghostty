// ignore_for_file: avoid_print
import 'dart:io';

import 'package:crypto/crypto.dart';
import 'package:path/path.dart' as p;

/// SHA256 hashes for pre-built native binaries.
///
/// A GH actions step will download all libghostty binaries attached to a
/// release to `artifacts/`.
///
/// This program replaces `lib/src/hook/asset_hashes.dart` to reference
/// those hashes.
///
/// When given an argument, that is interpreted as a tag name about to be
/// released. It asserts the source matches what this script would generate.
void main(List<String> args) {
  if (args.isEmpty) {
    throw ArgumentError(
      'Usage: dart run tool/generate_binary_hash.dart <artifacts-path> [release-tag]',
    );
  }

  final artifactsPath = args[0];
  final releaseTag = args.length > 1 ? args[1] : null;
  final artifacts = Directory(artifactsPath);
  if (!artifacts.existsSync()) {
    print('Error: $artifactsPath not found');
    exit(1);
  }

  final files =
      artifacts
          .listSync()
          .whereType<File>()
          .where((f) => p.basename(f.path).startsWith('libghostty-'))
          .toList()
        ..sort((a, b) => a.path.compareTo(b.path));

  final buffer = StringBuffer();

  buffer.writeln('''
// --- DO NOT EDIT MANUALLY ---
// This file contains hashes of libghostty binaries downloaded by the build
// hook. For tests, it is replaced with actual assets built from the tarballs.
// For releases, a pre-release check asserts it's up-to-date.
//
// Generated by tool/generate_binary_hash.dart

// dart format off
// ignore_for_file: unnecessary_ignore, lines_longer_than_80_chars

/// The release tag used for downloading prebuilt binaries.
const releaseTag = ${releaseTag != null ? "'$releaseTag'" : 'null'};

/// SHA256 hashes for pre-built native binaries. Keys are the artifact
/// filenames.
const assetHashes = <String, String>{''');

  for (final file in files) {
    final name = p.basename(file.path);
    final hash = sha256.convert(file.readAsBytesSync());
    buffer.writeln("  '$name': '$hash',");
  }

  buffer.writeln('};');

  final targetPath = p.join('lib', 'src', 'hook', 'asset_hashes.dart');
  File(targetPath)
    ..createSync(recursive: true)
    ..writeAsStringSync(buffer.toString());

  print('Wrote hashes to $targetPath');
}
